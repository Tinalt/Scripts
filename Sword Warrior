local kavoUi = loadstring(game:HttpGet("https://raw.githubusercontent.com/Toilatin/Insane-elevator/main/Insane2"))()
local window = kavoUi.CreateLib("Sword Warrior [UPDATE]","BloodTheme")

---Hi

local Tab1 = window:NewTab("AutoFarm")
local Tab1Section = Tab1:NewSection("AutoFarm")

local Tab2 = window:NewTab("Endless Mode")
local Tab2Section = Tab2:NewSection("Teleports")

local Tab3 = window:NewTab("Auto Drillmaster")
local Tab3Section = Tab3:NewSection("Auto DrillMaster")

local Tab4 = window:NewTab("Scripts")
local Tab4Section = Tab4:NewSection("Scripts")

local Tab5 = window:NewTab("Teleport")
local Tab5Section = Tab5:NewSection("Teleport")

local Tab6 = window:NewTab("Settings")
local Tab6Section = Tab6:NewSection("Settings")

local Tab7 = window:NewTab("Credits")
local Tab7Section = Tab7:NewSection("-----Credits-----")
local Tab7Section = Tab7:NewSection("---Owner---")
local Tab7Section = Tab7:NewSection("--Tin--")


--Toggle Button

local gui = Instance.new("ScreenGui")
gui.Name = "tinGui"
gui.Parent = game.CoreGui

local TextButton = Instance.new("TextButton")
TextButton.Text = "Show\nui"
TextButton.TextSize = 14
TextButton.TextColor3 = Color3.new(1, 1, 1)
TextButton.BackgroundColor3 = Color3.new(0, 0, 0)
TextButton.BorderColor3 = Color3.new(0, 0, 0)
TextButton.BackgroundTransparency = 0.5
TextButton.BorderSizePixel = 4
TextButton.Font = Enum.Font.Code
TextButton.Size = UDim2.new(0, 50, 0, 50)
TextButton.Position = UDim2.new(1, -110, 0, 10)

local isVisible = false
TextButton.MouseButton1Click:Connect(function()
    isVisible = not isVisible
    if isVisible then
        TextButton.Text = "Hide\nui"
    else
        TextButton.Text = "Show\nui"
    end
    kavoUi:ToggleUI()
end)
TextButton.Parent = gui
TextButton.Draggable = true

local cornerUI = Instance.new("UICorner")
cornerUI.CornerRadius = UDim.new(0, 5)
cornerUI.Parent = TextButton

local uiStroke = Instance.new("UIStroke")
uiStroke.Color = Color3.new(0, 0, 0)
uiStroke.Thickness = 2
uiStroke.Parent = TextButton





--- Notification Function ---
local currentNotification = nil  -- Keeps track of the current notification

local function showNotify(message)
    -- Remove the existing notification if it exists
    if currentNotification then
        currentNotification:Destroy()
    end

    -- Create a ScreenGui
    local screenGui = Instance.new("ScreenGui")
    screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

    -- Create a TextLabel for the notification
    local notification = Instance.new("TextLabel")
    notification.Size = UDim2.new(0.25, 0, 0.13, 0)  -- Width and height of the notification
    notification.Position = UDim2.new(1, 0, 0.4, 0)  -- Start at the bottom of the screen
    notification.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2)  -- Dark grey background
    notification.BackgroundTransparency = 0.3  -- 30% transparent
    notification.BorderSizePixel = 3.5  -- Outline thickness
    notification.BorderColor3 = Color3.new(0, 0, 0)  -- Black outline
    notification.TextColor3 = Color3.new(1, 1, 1)  -- White text
    notification.TextScaled = true
    notification.TextWrapped = true
    notification.Text = message  -- Notification message
    notification.Font = Enum.Font.ArialBold
    notification.Parent = screenGui

    -- Add padding to the TextLabel
    local padding = Instance.new("UIPadding")
    padding.PaddingTop = UDim.new(0.1, 0)
    padding.PaddingBottom = UDim.new(0.1, 0)
    padding.PaddingLeft = UDim.new(0.1, 0)
    padding.PaddingRight = UDim.new(0.1, 0)
    padding.Parent = notification

    -- Use TweenService to create the slide animation
    local TweenService = game:GetService("TweenService")

    -- Shorten the duration for a faster animation
    local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local targetPosition1 = UDim2.new(0.74, 0, 0.4, 0)  -- Middle of the screen
    local targetPosition2 = UDim2.new(1, 0, 0.4, 0)  -- Bottom of the screen

    local slideUpTween = TweenService:Create(notification, tweenInfo, {Position = targetPosition1})
    local slideDownTween = TweenService:Create(notification, tweenInfo, {Position = targetPosition2})

    -- Play the slide up tween
    slideUpTween:Play()

    -- After the slide up tween completes, wait for 3 seconds and then play the slide down tween
    slideUpTween.Completed:Connect(function()
        wait(1.5)
        slideDownTween:Play()
    end)

    -- Destroy the screenGui after the slide down tween completes
    slideDownTween.Completed:Connect(function()
        screenGui:Destroy()
    end)

    -- Update the reference to the current notification
    currentNotification = notification
end



--- Notification Function (INTRO) ---

local currentNotification = nil  -- Keeps track of the current notification

local function showNotify(message)
    -- Remove the existing notification if it exists
    if currentNotification then
        currentNotification:Destroy()
    end

    -- Create a ScreenGui
    local screenGui = Instance.new("ScreenGui")
    screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

    -- Create a TextLabel for the notification
    local notification = Instance.new("TextLabel")
    notification.Size = UDim2.new(0.25, 0, 0.13, 0)  -- Width and height of the notification
    notification.Position = UDim2.new(1, 0, 0.4, 0)  -- Start at the bottom of the screen
    notification.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2)  -- Dark grey background
    notification.BackgroundTransparency = 0.3  -- 30% transparent
    notification.BorderSizePixel = 3.5  -- Outline thickness
    notification.BorderColor3 = Color3.new(0, 0, 0)  -- Black outline
    notification.TextColor3 = Color3.new(1, 1, 1)  -- White text
    notification.TextScaled = true
    notification.TextWrapped = true
    notification.Text = message  -- Notification message
    notification.Font = Enum.Font.ArialBold
    notification.Parent = screenGui

    -- Add padding to the TextLabel
    local padding = Instance.new("UIPadding")
    padding.PaddingTop = UDim.new(0.1, 0)
    padding.PaddingBottom = UDim.new(0.1, 0)
    padding.PaddingLeft = UDim.new(0.1, 0)
    padding.PaddingRight = UDim.new(0.1, 0)
    padding.Parent = notification

    -- Use TweenService to create the slide animation
    local TweenService = game:GetService("TweenService")

    -- Shorten the duration for a faster animation
    local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local targetPosition1 = UDim2.new(0.74, 0, 0.4, 0)  -- Middle of the screen
    local targetPosition2 = UDim2.new(1, 0, 0.4, 0)  -- Bottom of the screen

    local slideUpTween = TweenService:Create(notification, tweenInfo, {Position = targetPosition1})
    local slideDownTween = TweenService:Create(notification, tweenInfo, {Position = targetPosition2})

    -- Play the slide up tween
    slideUpTween:Play()

    -- After the slide up tween completes, wait for 3 seconds and then play the slide down tween
    slideUpTween.Completed:Connect(function()
        wait(5)
        slideDownTween:Play()
    end)

    -- Destroy the screenGui after the slide down tween completes
    slideDownTween.Completed:Connect(function()
        screenGui:Destroy()
    end)

    -- Update the reference to the current notification
    currentNotification = notification
end




showNotify("OP Sword Warrior Script Enjoy! :)")







-----------------SafeSpots (ENDLESS MODE)-------------------

local SafeSpot = Instance.new("Part", workspace)

SafeSpot.Position = Vector3.new(19.22,6.03,-6545.26)

SafeSpot.Name = "EndlessEnter"

SafeSpot.Size = Vector3.new(0,0.1,0)

SafeSpot.Anchored = true

SafeSpot.CanCollide = false

SafeSpot.Transparency = 1

--

local SafeSpot = Instance.new("Part", workspace)

SafeSpot.Position = Vector3.new(4764.1,42.31,-2257.39)

SafeSpot.Name = "EndlessArea"

SafeSpot.Size = Vector3.new(0,0.1,0)

SafeSpot.Anchored = true

SafeSpot.CanCollide = false

SafeSpot.Transparency = 1

---

local SafeSpot = Instance.new("Part", workspace)

SafeSpot.Position = Vector3.new(4761.73,41,-2256.59)

SafeSpot.Name = "SafeEndless"

SafeSpot.Size = Vector3.new(2050,1,2050)

SafeSpot.Anchored = true

SafeSpot.Transparency = .7

---

local SafeSpot = Instance.new("Part", workspace)

SafeSpot.Position = Vector3.new(4780.71,53.5,-2161.81)

SafeSpot.Name = "OutsideEnd"

SafeSpot.Size = Vector3.new(1,1,1)

SafeSpot.Anchored = true

SafeSpot.CanCollide = false

SafeSpot.Transparency = 1

--------------END ENDLESS MODE---------------












-----TAB1-----











local player = game:GetService("Players").LocalPlayer
local autoExecuteEnabled = false
local customTime = 10 -- Default to 10 seconds

-- Function to reset data
local function ResetData()
    local args = {
        [1] = "ResetPoints"
    }
    game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args))
end

-- Function to increase critical hit
local function CritUp()
    local args = {
        [1] = "ClickPoints",
        [2] = {
            ["Points"] = 240,
            ["Obj"] = "GCriticalHit"
        }
    }
    game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args))
end

-- Function to heal health
local function HealHealth()
    local args = {
        [1] = "ClickPoints",
        [2] = {
            ["Points"] = 999999,
            ["Obj"] = "GHealth"
        }
    }
    game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args))
end

-- Function to run the three scripts in sequence
local function executeActions()
    while autoExecuteEnabled do
        ResetData()
        wait(0.0001)
        CritUp()
        wait(0.001)
        HealHealth()
        wait(customTime) -- Wait for the custom time before running the script again
    end
end

-- Toggle button for auto-executing
Tab1Section:NewToggle("Auto Heal", "Auto Heal Full Health", function(state)
    autoExecuteEnabled = state
    if state then
        -- Run the actions in a new thread to prevent blocking
        spawn(executeActions)
    end
end)

-- Textbox to input custom time
Tab1Section:NewTextBox("Auto Heal Custom Time", "Enter the time in seconds", function(value)
    local inputTime = tonumber(value) -- Convert the textbox input to a number
    if inputTime and inputTime > 0 then
        customTime = inputTime -- Set customTime to the new value
        showNotify("Auto Heal time set to " .. inputTime .. "s")
    else
        showNotify("Invalid input. Please enter a valid number greater than 0.")
    end
end)


local player = game:GetService("Players").LocalPlayer
local autoExecuteEnabled = false
local customTime = 10 -- Default to 10 seconds

-- Function to reset data
local function ResetData()
    local args = {
        [1] = "ResetPoints"
    }
    game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args))
end

-- Function to increase critical hit
local function CritUp()
    local args = {
        [1] = "ClickPoints",
        [2] = {
            ["Points"] = 240,
            ["Obj"] = "GCriticalHit"
        }
    }
    game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args))
end

-- Function to increase attack damage
local function Attack()
    local args = {
        [1] = "ClickPoints",
        [2] = {
            ["Points"] = 999999,
            ["Obj"] = "GDamage"
        }
    }
    game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args))
end

-- Function to run both scripts in sequence
local function executeActions()
    while autoExecuteEnabled do
        ResetData()
        wait(0.0001)
        CritUp()
        wait(0.001)
        Attack()
        wait(customTime) -- Wait for the custom time before running the script again
    end
end

-- Toggle button for auto-executing both scripts
Tab1Section:NewToggle("Auto Upgrade Attack", "Auto Upgrade Attack", function(state)
    autoExecuteEnabled = state
    if state then
        -- Run the actions in a new thread to prevent blocking
        spawn(executeActions)
    end
end)

-- Textbox to input custom time
Tab1Section:NewTextBox("Auto Attack Custom Time", "Enter the time in seconds", function(value)
    local inputTime = tonumber(value) -- Convert the textbox input to a number
    if inputTime and inputTime > 0 then
        customTime = inputTime -- Set customTime to the new value
        showNotify("Auto Attack time set to " .. inputTime .. "s")
    else
        showNotify("Invalid input. Please enter a valid number greater than 0.")
    end
end)


local runScript = false
local interval = 10 -- Default interval in seconds

-- Function definitions
local function ResetData()
    local args = {
        [1] = "ResetPoints"
    }
    game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args))
end

local function CritUp()
    local args = {
        [1] = "ClickPoints",
        [2] = {
            ["Points"] = 240,
            ["Obj"] = "GCriticalHit"
        }
    }
    game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args))
end

local function Attack()
    local args = {
        [1] = "ClickPoints",
        [2] = {
            ["Points"] = 999999,
            ["Obj"] = "GDamage"
        }
    }
    game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args))
end

local function HealHealth()
    local args = {
        [1] = "ClickPoints",
        [2] = {
            ["Points"] = 999999,
            ["Obj"] = "GHealth"
        }
    }
    game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args))
end

-- Function to execute the script
local function executeScript()
    while runScript do
        ResetData()
        wait(0.0001)
        HealHealth()
        wait(0.001)
        ResetData()
        wait(0.001)
        CritUp()
        wait(0.001)
        Attack()
        wait(interval) -- Wait for the specified interval
    end
end

-- Toggle button for enabling/disabling the script
Tab1Section:NewToggle("Auto Heal + Attack", "Instant Heal + Attack", function(state)
    runScript = state
    if state then
        executeScript() -- Start the script execution
    end
end)

-- Textbox for setting the interval
Tab1Section:NewTextBox("Heal + ATK", "Set the time in seconds", function(value)
    local num = tonumber(value)
    if num and num > 0 then
        interval = num
        showNotify("Auto Heal + ATK time set to " .. value .. "s")
    else
        showNotify("Invalid input. Please enter a valid number greater than 0")
    end
end)


local virtualInputManager = game:GetService("VirtualInputManager")

-- Function to simulate key presses
local function simulateKeyPress()
    while true do
        wait(600) -- Wait 10 minutes before simulating input (adjust time as needed)
        virtualInputManager:SendKeyEvent(true, Enum.KeyCode.W, false, game) -- Simulate pressing "W" key
        wait(0.1)
        virtualInputManager:SendKeyEvent(false, Enum.KeyCode.W, false, game) -- Simulate releasing "W" key
    end
end

-- Toggle state variable
local antiAFKActive = false

-- Function to start or stop the anti-AFK feature
local function toggleAntiAFK(state)
    antiAFKActive = state
    if antiAFKActive then
        showNotify("Anti Afk: ON")
        spawn(simulateKeyPress)
    else
        showNotify("Anti Afk: OFF")
    end
end

-- Example UI Toggle
Tab1Section:NewToggle("Anti Afk ", "This Anti Afk is different", function(state)
    toggleAntiAFK(state)
end)
























local Tab1Section = Tab1:NewSection("World 12")


-- Define the target positions

--targetPosition1 is SafePlace
--targetPosition2 is attract the monsters
--targetPosition3 is tp outside the map to avoid losing health when attract the monsters
--targetPosition3 is attract the monsters (World 12 Bonus)

local targetPosition1 = Vector3.new(-38870, 4.400007724761963, 19732)
local targetPosition2 = Vector3.new(-38954.453125, 4.500006198883057, 19770.396484375)
local targetPosition3 = Vector3.new(-38803.5078125, 4.000007629394531, 19797.845703125)
local targetPosition4 = Vector3.new(-38926.78515625, 4.500007152557373, 19695.060546875)

-- Get the player's character
local player = game:GetService("Players").LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Variable to control teleportation
local teleportEnabled = false
local teleportStopped = false

-- Function to teleport the player with a delay
local function teleportPlayer(targetPosition)
    local rootPart = character:WaitForChild("HumanoidRootPart")
    rootPart.CFrame = CFrame.new(targetPosition)
end

-- Function to handle the teleportation loop
local function autoTeleport()
    while teleportEnabled do
        if teleportStopped then
            wait() -- Wait indefinitely until teleportStopped is set to false
        else
            -- Teleport to the first position
            teleportPlayer(targetPosition3)
            wait(0.1) -- Wait 0.1 seconds

            -- Teleport to the second position
            teleportPlayer(targetPosition2)
            wait(0.0001) -- Wait 0.1 seconds

            -- Teleport to the second position
            teleportPlayer(targetPosition4)
            wait(0.0001) -- Wait 0.1 seconds


            -- Teleport to the second position
            teleportPlayer(targetPosition1)
            wait(0.1) -- Wait 0.1 seconds

            -- Wait for 10-20 seconds before repeating
            local waitTime = math.random(10, 20)
            wait(waitTime)
        end
    end
end


local function createWorld12Map1()
    local world12map1 = Instance.new("Part", workspace)
    world12map1.Position = Vector3.new(-38926.7,1,19683.88)
    world12map1.Name = "World12Map1"
    world12map1.Size = Vector3.new(25, 3, 25)
    world12map1.Anchored = true
    world12map1.CanCollide = false
    world12map1.Transparency = 0.7
end

-- Function to create another part
local function createWorld12Map2()
    local world12Map2 = Instance.new("Part", workspace)
    world12Map2.Position = Vector3.new(-38934.31,13.45,19524.19)
    world12Map2.Name = "World12Map2"
    world12Map2.Size = Vector3.new(27, 3, 27)
    world12Map2.Anchored = true
    world12Map2.CanCollide = false
    world12Map2.Transparency = 0.7

    -- Connect the touched event for World12Map2
    world12Map2.Touched:Connect(function(hit)
        if hit.Parent == player.Character then
            teleportStopped = true
        end
    end)
end

-- Function to create another part
local function createWorld12Map3()
    local world12Map3 = Instance.new("Part", workspace)
    world12Map3.Position = Vector3.new(-38869.78,1,19731.45)
    world12Map3.Name = "World12Map3"
    world12Map3.Size = Vector3.new(20, 3, 20)
    world12Map3.Anchored = true
    world12Map3.CanCollide = false
    world12Map3.Transparency = 0.7

    -- Connect the touched event for World12Map3
    world12Map3.Touched:Connect(function(hit)
        if hit.Parent == player.Character then
            if teleportStopped then
                teleportStopped = false -- Resume teleportation
            end
        end
    end)
end

-- Function to delete the World12Map1 part
local function deleteWorld12Map1()
    local world12map1 = workspace:FindFirstChild("World12Map1")
    if world12map1 then
        world12map1:Destroy()
    end
end

-- Function to delete the World12Map2 part
local function deleteWorld12Map2()
    local world12Map2 = workspace:FindFirstChild("World12Map2")
    if world12Map2 then
        world12Map2:Destroy()
    end
end

-- Function to delete the World12Map3 part
local function deleteWorld12Map3()
    local world12Map3 = workspace:FindFirstChild("World12Map3")
    if world12Map3 then
        world12Map3:Destroy()
    end
end

--BUTTON--
Tab1Section:NewToggle("AutoFarm", "AutoFarm World 12 (Required Auto Teleport", function(state)
    teleportEnabled = state
    if state then
        createWorld12Map1() -- Create the SafeSpot part
        createWorld12Map2() -- Create the World10Map2 part
        createWorld12Map3() -- Create the World10Map3 part
        autoTeleport() -- Start the teleport loop
    else
        deleteWorld12Map1() -- Delete the SafeSpot part
        deleteWorld12Map2() -- Delete the World10Map2 part
        deleteWorld12Map3() -- Delete the World10Map3 part
    end
end)



-- Define the target positions
local targetPosition1 = Vector3.new(-38870, 4.400005340576172, 19732)
local targetPosition2 = Vector3.new(-38927.5625, 4.95576286315918, 19618.453125)

-- Get the player's character
local player = game:GetService("Players").LocalPlayer

-- Function to teleport the player with a delay
local function teleportPlayer(character, targetPosition)
    local rootPart = character:WaitForChild("HumanoidRootPart")
    wait(0.1)  -- Wait for 0.1 seconds
    rootPart.CFrame = CFrame.new(targetPosition)
end

-- Function to set up the teleport when the character touches a part
local function setupTeleport(targetPart, targetPosition)
    targetPart.Touched:Connect(function(hit)
        if hit.Parent == player.Character then
            teleportPlayer(player.Character, targetPosition)
        end
    end)
end

-- Function to handle part creation or re-creation
local function handlePart(partName, targetPosition)
    local workspace = game:GetService("Workspace")

    -- Check if the part exists and set up teleport functionality
    local targetPart = workspace:FindFirstChild(partName)
    if targetPart then
        setupTeleport(targetPart, targetPosition)
    end

    -- Continuously check for the part's re-creation
    workspace.ChildAdded:Connect(function(child)
        if child.Name == partName then
            setupTeleport(child, targetPosition)
        end
    end)
end

-- Function to run the setup and checks periodically
local function periodicUpdate()
    while true do
        handlePart("World12Map1", targetPosition1)
        handlePart("World12Map2", targetPosition2)
        wait(25) -- Wait 25 seconds before running again
    end
end

-- Toggle button logic
local isEnabled = false

Tab1Section:NewToggle("Auto Teleport", "Turn this on for AutoFarm to work", function(state)
    isEnabled = state
    if state then
        coroutine.wrap(periodicUpdate)() -- Start the periodic update in a coroutine
    end
end)














-- Anti-AFK Simple Walk Script with Toggle (Run to position 2 times every 10 mins, with touch logic and timer continuation)

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local targetPosition = Vector3.new(-38871.03125, 4.00000524520874, 19716.115234375)

local teleportEnabled = false -- Variable to track if the teleport is enabled
local touchDisabled = false -- Variable to track if touching World12Map2 disables teleport
local remainingTime = 600 -- Start with 10 minutes (600 seconds)
local lastTime = tick() -- Store the current time when the script starts

-- Function to move the character to the target position 2 times
local function autoMove()
    while teleportEnabled do
        if not touchDisabled then
            for i = 1, 2 do
                humanoid:MoveTo(targetPosition)
                wait(1) -- Small wait to allow the movement to complete before moving again
            end
        end

        -- Check how much time has passed since the last movement and update remainingTime
        local timeElapsed = tick() - lastTime
        remainingTime = remainingTime - timeElapsed
        lastTime = tick() -- Reset the last time

        -- If the remaining time is more than 0, wait for the remaining time
        if remainingTime > 0 then
            wait(remainingTime)
        end

        -- Reset the timer after 10 minutes (600 seconds)
        remainingTime = 600
    end
end

-- Function to handle touching World12Map2 and World12Map3 parts
local function setupTouchListeners()
    local world12Map2 = game:GetService("Workspace").World12Map2
    local world12Map3 = game:GetService("Workspace").World12Map3

    -- When the player touches World12Map2, disable movement and stop the timer
    world12Map2.Touched:Connect(function(hit)
        if hit.Parent == character then
            touchDisabled = true
        end
    end)

    -- When the player touches World12Map3, re-enable movement and continue the timer
    world12Map3.Touched:Connect(function(hit)
        if hit.Parent == character then
            touchDisabled = false
            lastTime = tick() -- Update the time when movement is resumed
        end
    end)
end

-- Toggle button functionality
Tab1Section:NewToggle("Anti Afk (BETA) (W12) (TURN ON AUTOFARM FIRST)", "Anti Afk", function(state)
    teleportEnabled = state
    if state then
        print("Toggle On")
        setupTouchListeners() -- Set up the touch detection
        lastTime = tick() -- Reset the time when toggle is enabled
        -- Start the movement loop in a new thread so it doesn't block other code
        spawn(autoMove)
    else
        print("Toggle Off")
    end
end)





























local Tab1Section = Tab1:NewSection("World 11")


-- Define the target positions

--targetPosition1 is SafePlace
--targetPosition2 is attract the monsters
--targetPosition3 is tp outside the map to avoid losing health when attract the monsters

local targetPosition1 = Vector3.new(-26165, 4.000006198883057, 19702)
local targetPosition2 = Vector3.new(-26094.375, 4.000007629394531, 19760.14453125)
local targetPosition3 = Vector3.new(-26258.328125, 5.650812149047852, 19793.419921875)

-- Get the player's character
local player = game:GetService("Players").LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Variable to control teleportation
local teleportEnabled = false
local teleportStopped = false

-- Function to teleport the player with a delay
local function teleportPlayer(targetPosition)
    local rootPart = character:WaitForChild("HumanoidRootPart")
    rootPart.CFrame = CFrame.new(targetPosition)
end

-- Function to handle the teleportation loop
local function autoTeleport()
    while teleportEnabled do
        if teleportStopped then
            wait() -- Wait indefinitely until teleportStopped is set to false
        else
            -- Teleport to the first position
            teleportPlayer(targetPosition3)
            wait(0.1) -- Wait 0.1 seconds

            -- Teleport to the second position
            teleportPlayer(targetPosition2)
            wait(0.01) -- Wait 0.1 seconds

            -- Teleport to the second position
            teleportPlayer(targetPosition1)
            wait(0.1) -- Wait 0.1 seconds

            -- Wait for 10-20 seconds before repeating
            local waitTime = math.random(10, 20)
            wait(waitTime)
        end
    end
end


local function createWorld11Map1()
    local world11map1 = Instance.new("Part", workspace)
    world11map1.Position = Vector3.new(-26096.75,1,19683.96)
    world11map1.Name = "World11Map1"
    world11map1.Size = Vector3.new(20, 3, 20)
    world11map1.Anchored = true
    world11map1.CanCollide = false
    world11map1.Transparency = 0.7
end

-- Function to create another part
local function createWorld11Map2()
    local world11Map2 = Instance.new("Part", workspace)
    world11Map2.Position = Vector3.new(-26109,43.37,19524.38)
    world11Map2.Name = "World11Map2"
    world11Map2.Size = Vector3.new(20, 3, 20)
    world11Map2.Anchored = true
    world11Map2.CanCollide = false
    world11Map2.Transparency = 0.7

    -- Connect the touched event for World11Map2
    world11Map2.Touched:Connect(function(hit)
        if hit.Parent == player.Character then
            teleportStopped = true
        end
    end)
end

-- Function to create another part
local function createWorld11Map3()
    local world11Map3 = Instance.new("Part", workspace)
    world11Map3.Position = Vector3.new(-26164.82,1,19701.78)
    world11Map3.Name = "World11Map3"
    world11Map3.Size = Vector3.new(20, 3, 20)
    world11Map3.Anchored = true
    world11Map3.CanCollide = false
    world11Map3.Transparency = 0.7

    -- Connect the touched event for World11Map3
    world11Map3.Touched:Connect(function(hit)
        if hit.Parent == player.Character then
            if teleportStopped then
                teleportStopped = false -- Resume teleportation
            end
        end
    end)
end

-- Function to delete the World11Map1 part
local function deleteWorld11Map1()
    local world11map1 = workspace:FindFirstChild("World11Map1")
    if world11map1 then
        world11map1:Destroy()
    end
end

-- Function to delete the World11Map2 part
local function deleteWorld11Map2()
    local world11Map2 = workspace:FindFirstChild("World11Map2")
    if world11Map2 then
        world11Map2:Destroy()
    end
end

-- Function to delete the World11Map3 part
local function deleteWorld11Map3()
    local world11Map3 = workspace:FindFirstChild("World11Map3")
    if world11Map3 then
        world11Map3:Destroy()
    end
end

--BUTTON--
Tab1Section:NewToggle("AutoFarm", "AutoFarm World 11 (Required Auto Teleport", function(state)
    teleportEnabled = state
    if state then
        createWorld11Map1() -- Create the SafeSpot part
        createWorld11Map2() -- Create the World10Map2 part
        createWorld11Map3() -- Create the World10Map3 part
        autoTeleport() -- Start the teleport loop
    else
        deleteWorld11Map1() -- Delete the SafeSpot part
        deleteWorld11Map2() -- Delete the World10Map2 part
        deleteWorld11Map3() -- Delete the World10Map3 part
    end
end)



-- Define the target positions
local targetPosition1 = Vector3.new(-26165, 4.400006294250488, 19702)
local targetPosition2 = Vector3.new(-26102.7421875, 50.58808135986328, 19606.52734375)

-- Get the player's character
local player = game:GetService("Players").LocalPlayer

-- Function to teleport the player with a delay
local function teleportPlayer(character, targetPosition)
    local rootPart = character:WaitForChild("HumanoidRootPart")
    wait(0.1)  -- Wait for 0.1 seconds
    rootPart.CFrame = CFrame.new(targetPosition)
end

-- Function to set up the teleport when the character touches a part
local function setupTeleport(targetPart, targetPosition)
    targetPart.Touched:Connect(function(hit)
        if hit.Parent == player.Character then
            teleportPlayer(player.Character, targetPosition)
        end
    end)
end

-- Function to handle part creation or re-creation
local function handlePart(partName, targetPosition)
    local workspace = game:GetService("Workspace")

    -- Check if the part exists and set up teleport functionality
    local targetPart = workspace:FindFirstChild(partName)
    if targetPart then
        setupTeleport(targetPart, targetPosition)
    end

    -- Continuously check for the part's re-creation
    workspace.ChildAdded:Connect(function(child)
        if child.Name == partName then
            setupTeleport(child, targetPosition)
        end
    end)
end

-- Function to run the setup and checks periodically
local function periodicUpdate()
    while true do
        handlePart("World11Map1", targetPosition1)
        handlePart("World11Map2", targetPosition2)
        wait(25) -- Wait 25 seconds before running again
    end
end

-- Toggle button logic
local isEnabled = false

Tab1Section:NewToggle("Auto Teleport", "Turn this on for AutoFarm to work", function(state)
    isEnabled = state
    if state then
        coroutine.wrap(periodicUpdate)() -- Start the periodic update in a coroutine
    end
end)
















local Tab1Section = Tab1:NewSection("World 10")


-- Define the target positions
local targetPosition1 = Vector3.new(-12965, 4.000007152557373, 19724)
local targetPosition2 = Vector3.new(-12899.7802734375, 4.000007629394531, 19753.53125)
local targetPosition3 = Vector3.new(-13150.3828125, 4.00000524520874, 19772.962890625)

-- Get the player's character
local player = game:GetService("Players").LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Variable to control teleportation
local teleportEnabled = false
local teleportStopped = false

-- Function to teleport the player with a delay
local function teleportPlayer(targetPosition)
    local rootPart = character:WaitForChild("HumanoidRootPart")
    rootPart.CFrame = CFrame.new(targetPosition)
end

-- Function to handle the teleportation loop
local function autoTeleport()
    while teleportEnabled do
        if teleportStopped then
            wait() -- Wait indefinitely until teleportStopped is set to false
        else
            -- Teleport to the first position
            teleportPlayer(targetPosition3)
            wait(0.1) -- Wait 0.1 seconds

            -- Teleport to the second position
            teleportPlayer(targetPosition2)
            wait(0.1) -- Wait 0.1 seconds

            -- Teleport to the second position
            teleportPlayer(targetPosition1)
            wait(0.1) -- Wait 0.1 seconds

            -- Wait for 10-20 seconds before repeating
            local waitTime = math.random(10, 20)
            wait(waitTime)
        end
    end
end

-- Function to create the SafeSpot part
local function createSafeSpot()
    local safeSpot = Instance.new("Part", workspace)
    safeSpot.Position = Vector3.new(-12900.73, 1, 19683.46)
    safeSpot.Name = "World10Map1"
    safeSpot.Size = Vector3.new(20, 3, 20)
    safeSpot.Anchored = true
    safeSpot.CanCollide = false
    safeSpot.Transparency = 0.7
end

-- Function to create another part
local function createWorld10Map2()
    local world10Map2 = Instance.new("Part", workspace)
    world10Map2.Position = Vector3.new(-12898.89, 2.19, 19547.2)
    world10Map2.Name = "World10Map2"
    world10Map2.Size = Vector3.new(20, 3, 20)
    world10Map2.Anchored = true
    world10Map2.CanCollide = false
    world10Map2.Transparency = 0.7

    -- Connect the touched event for World10Map2
    world10Map2.Touched:Connect(function(hit)
        if hit.Parent == player.Character then
            teleportStopped = true
        end
    end)
end

-- Function to create another part
local function createWorld10Map3()
    local world10Map3 = Instance.new("Part", workspace)
    world10Map3.Position = Vector3.new(-12965.24, 1, 19724.5)
    world10Map3.Name = "World10Map3"
    world10Map3.Size = Vector3.new(20, 3, 20)
    world10Map3.Anchored = true
    world10Map3.CanCollide = false
    world10Map3.Transparency = 0.7

    -- Connect the touched event for World10Map3
    world10Map3.Touched:Connect(function(hit)
        if hit.Parent == player.Character then
            if teleportStopped then
                teleportStopped = false -- Resume teleportation
            end
        end
    end)
end

-- Function to delete the SafeSpot part
local function deleteSafeSpot()
    local safeSpot = workspace:FindFirstChild("World10Map1")
    if safeSpot then
        safeSpot:Destroy()
    end
end

-- Function to delete the World10Map2 part
local function deleteWorld10Map2()
    local world10Map2 = workspace:FindFirstChild("World10Map2")
    if world10Map2 then
        world10Map2:Destroy()
    end
end

-- Function to delete the World10Map3 part
local function deleteWorld10Map3()
    local world10Map3 = workspace:FindFirstChild("World10Map3")
    if world10Map3 then
        world10Map3:Destroy()
    end
end

--BUTTON--
Tab1Section:NewToggle("AutoFarm", "AutoFarm World 10 (Required Auto Teleport", function(state)
    teleportEnabled = state
    if state then
        createSafeSpot() -- Create the SafeSpot part
        createWorld10Map2() -- Create the World10Map2 part
        createWorld10Map3() -- Create the World10Map3 part
        autoTeleport() -- Start the teleport loop
    else
        deleteSafeSpot() -- Delete the SafeSpot part
        deleteWorld10Map2() -- Delete the World10Map2 part
        deleteWorld10Map3() -- Delete the World10Map3 part
    end
end)



-- Define the target positions
local targetPosition1 = Vector3.new(-12965, 4.000007152557373, 19724)
local targetPosition2 = Vector3.new(-12898.8603515625, 5.1916184425354, 19619.599609375) -- Adjust this if different for World10Map2

-- Get the player's character
local player = game:GetService("Players").LocalPlayer

-- Function to teleport the player with a delay
local function teleportPlayer(character, targetPosition)
    local rootPart = character:WaitForChild("HumanoidRootPart")
    wait(0.1)  -- Wait for 0.1 seconds
    rootPart.CFrame = CFrame.new(targetPosition)
end

-- Function to set up the teleport when the character touches a part
local function setupTeleport(targetPart, targetPosition)
    targetPart.Touched:Connect(function(hit)
        if hit.Parent == player.Character then
            teleportPlayer(player.Character, targetPosition)
        end
    end)
end

-- Function to handle part creation or re-creation
local function handlePart(partName, targetPosition)
    local workspace = game:GetService("Workspace")

    -- Check if the part exists and set up teleport functionality
    local targetPart = workspace:FindFirstChild(partName)
    if targetPart then
        setupTeleport(targetPart, targetPosition)
    end

    -- Continuously check for the part's re-creation
    workspace.ChildAdded:Connect(function(child)
        if child.Name == partName then
            setupTeleport(child, targetPosition)
        end
    end)
end

-- Function to run the setup and checks periodically
local function periodicUpdate()
    while true do
        handlePart("World10Map1", targetPosition1)
        handlePart("World10Map2", targetPosition2)
        wait(25) -- Wait 25 seconds before running again
    end
end

-- Toggle button logic
local isEnabled = false

Tab1Section:NewToggle("Auto Teleport", "Turn this on for AutoFarm to work", function(state)
    isEnabled = state
    if state then
        coroutine.wrap(periodicUpdate)() -- Start the periodic update in a coroutine
    end
end)















Tab2Section:NewButton("Endless Area","Teleport to Endless Area",function()

game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = workspace.EndlessArea.CFrame * CFrame.new(0,5,0)
end)

Tab2Section:NewButton("Outside Endless (Cant die by mobs)","Teleport you to Outside Endless (Cant die by mobs)",function()

game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = workspace.OutsideEnd.CFrame * CFrame.new(0,0,0)
end)

local player = game:GetService("Players").LocalPlayer
local autoJumpEnabled = false

-- Function to handle auto-jumping
local function autoJump()
    local humanoid = player.Character:WaitForChild("Humanoid")
    while autoJumpEnabled do
        humanoid.Jump = true
        wait(0.1) -- Delay between jumps, adjust as needed
        humanoid.Jump = false
        wait(0.1) -- Delay to prevent continuous jumping
    end
end

-- Toggle button for auto-jumping
Tab2Section:NewToggle("Anti Afk", "Anti Afk", function(state)
    autoJumpEnabled = state
    if state then
        autoJump() -- Start auto-jumping loop
    end
end)

local Tab2Section = Tab2:NewSection("Enter Endless Mode")

Tab2Section:NewButton("Enter Endless Mode","Enter Endless Mode",function()

game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = workspace.EndlessEnter.CFrame * CFrame.new(0,5,0)
end)

local Tab2Section = Tab2:NewSection("Endless AutoFarm SOON!")









-- Variables to hold references to the parts
local drillMS1, drillMS2, drillMS3, drillMS4
local canSendRemoteHP = true -- Cooldown flag for DrillMS3
local canSendRemoteAttack = true -- Cooldown flag for DrillMS4

-- Function to create parts
local function createParts()
    -- Create the first part (DrillMS1)
    drillMS1 = Instance.new("Part", workspace)
    drillMS1.Position = Vector3.new(13.68, 5.31, -840.62)
    drillMS1.Name = "DrillMS1"
    drillMS1.Size = Vector3.new(20, 3, 20)
    drillMS1.Anchored = true
    drillMS1.CanCollide = false
    drillMS1.Transparency = 0.7

    -- Teleport functionality when touching DrillMS1
    drillMS1.Touched:Connect(function(hit)
        local player = game.Players:GetPlayerFromCharacter(hit.Parent)
        if player then
            local character = player.Character
            if character then
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    -- Teleport the player to the specified position
                    humanoidRootPart.CFrame = CFrame.new(74, 8.312800407409668, -818)
                end
            end
        end
    end)

    -- Create the second part (DrillMS2)
    drillMS2 = Instance.new("Part", workspace)
    drillMS2.Position = Vector3.new(73.89, 5.31, -818.48)
    drillMS2.Name = "DrillMS2"
    drillMS2.Size = Vector3.new(15, 3, 15)
    drillMS2.Anchored = true
    drillMS2.CanCollide = false
    drillMS2.Transparency = 0.7

    -- Create the third part (DrillMS3)
    drillMS3 = Instance.new("Part", workspace)
    drillMS3.Position = Vector3.new(-0.18, 22.79, 168.24)
    drillMS3.Name = "DrillMS3"
    drillMS3.Size = Vector3.new(25, 3, 25)
    drillMS3.Anchored = true
    drillMS3.CanCollide = false
    drillMS3.Transparency = 0.7

    -- Run the remote function when touching DrillMS3 with cooldown
    drillMS3.Touched:Connect(function(hit)
        if canSendRemoteHP then
            local player = game.Players:GetPlayerFromCharacter(hit.Parent)
            if player then
                local args = {
    [1] = "Drillmaster",
    [2] = "hp"
}

game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args))

                canSendRemoteHP = false -- Set cooldown
                wait(5) -- Cooldown period
                canSendRemoteHP = true -- Reset cooldown
            end
        end
    end)

    -- Create the fourth part (DrillMS4)
    drillMS4 = Instance.new("Part", workspace)
    drillMS4.Position = Vector3.new(1.55, 31.65, 35.39)
    drillMS4.Name = "DrillMS4"
    drillMS4.Size = Vector3.new(30, 2, 30)
    drillMS4.Anchored = true
    drillMS4.CanCollide = false
    drillMS4.Transparency = 0.7

    -- Run the remote function when touching DrillMS4 with cooldown
    drillMS4.Touched:Connect(function(hit)
        if canSendRemoteAttack then
            local player = game.Players:GetPlayerFromCharacter(hit.Parent)
            if player then
                local args = {
                    [1] = "Drillmaster",
                    [2] = "hp"
                }
                game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args))
                canSendRemoteAttack = false -- Set cooldown
                wait(5) -- Cooldown period
                canSendRemoteAttack = true -- Reset cooldown
            end
        end
    end)
end

-- Function to delete parts
local function deleteParts()
    if drillMS1 then
        drillMS1:Destroy()
        drillMS1 = nil
    end
    if drillMS2 then
        drillMS2:Destroy()
        drillMS2 = nil
    end
    if drillMS3 then
        drillMS3:Destroy()
        drillMS3 = nil
    end
    if drillMS4 then
        drillMS4:Destroy()
        drillMS4 = nil
    end
end

-- Toggle button functionality
Tab3Section:NewToggle("Auto Health", "Auto Do Drillmaster Health", function(state)
    if state then
        createParts()
        
        -- Run the remote when toggled on
        local args = {
    [1] = "Royal City"
}

game:GetService("ReplicatedStorage").Remotes.Chuansong:FireServer(unpack(args))

    else
        deleteParts()
    end
end)








-- Variables to hold references to the parts
local drillMS1, drillMS2, drillMS3, drillMS4
local canSendRemoteHP = true -- Cooldown flag for DrillMS3
local canSendRemoteAttack = true -- Cooldown flag for DrillMS4

-- Function to create parts
local function createParts()
    -- Create the first part (DrillMS1)
    drillMS1 = Instance.new("Part", workspace)
    drillMS1.Position = Vector3.new(13.68, 5.31, -840.62)
    drillMS1.Name = "DrillMS1"
    drillMS1.Size = Vector3.new(20, 3, 20)
    drillMS1.Anchored = true
    drillMS1.CanCollide = false
    drillMS1.Transparency = 0.7

    -- Teleport functionality when touching DrillMS1
    drillMS1.Touched:Connect(function(hit)
        local player = game.Players:GetPlayerFromCharacter(hit.Parent)
        if player then
            local character = player.Character
            if character then
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    -- Teleport the player to the specified position
                    humanoidRootPart.CFrame = CFrame.new(74, 8.312800407409668, -818)
                end
            end
        end
    end)

    -- Create the second part (DrillMS2)
    drillMS2 = Instance.new("Part", workspace)
    drillMS2.Position = Vector3.new(73.89, 5.31, -818.48)
    drillMS2.Name = "DrillMS2"
    drillMS2.Size = Vector3.new(15, 3, 15)
    drillMS2.Anchored = true
    drillMS2.CanCollide = false
    drillMS2.Transparency = 0.7

    -- Create the third part (DrillMS3)
    drillMS3 = Instance.new("Part", workspace)
    drillMS3.Position = Vector3.new(-0.18, 22.79, 168.24)
    drillMS3.Name = "DrillMS3"
    drillMS3.Size = Vector3.new(25, 3, 25)
    drillMS3.Anchored = true
    drillMS3.CanCollide = false
    drillMS3.Transparency = 0.7

    -- Run the remote function when touching DrillMS3 with cooldown
    drillMS3.Touched:Connect(function(hit)
        if canSendRemoteHP then
            local player = game.Players:GetPlayerFromCharacter(hit.Parent)
            if player then
                local args = {
    [1] = "Drillmaster",
    [2] = "attack"
}

game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args))

                canSendRemoteHP = false -- Set cooldown
                wait(5) -- Cooldown period
                canSendRemoteHP = true -- Reset cooldown
            end
        end
    end)

    -- Create the fourth part (DrillMS4)
    drillMS4 = Instance.new("Part", workspace)
    drillMS4.Position = Vector3.new(1.55, 31.65, 35.39)
    drillMS4.Name = "DrillMS4"
    drillMS4.Size = Vector3.new(30, 2, 30)
    drillMS4.Anchored = true
    drillMS4.CanCollide = false
    drillMS4.Transparency = 0.7

    -- Run the remote function when touching DrillMS4 with cooldown
    drillMS4.Touched:Connect(function(hit)
        if canSendRemoteAttack then
            local player = game.Players:GetPlayerFromCharacter(hit.Parent)
            if player then
                local args = {
                    [1] = "Drillmaster",
                    [2] = "attack"
                }
                game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args))
                canSendRemoteAttack = false -- Set cooldown
                wait(5) -- Cooldown period
                canSendRemoteAttack = true -- Reset cooldown
            end
        end
    end)
end

-- Function to delete parts
local function deleteParts()
    if drillMS1 then
        drillMS1:Destroy()
        drillMS1 = nil
    end
    if drillMS2 then
        drillMS2:Destroy()
        drillMS2 = nil
    end
    if drillMS3 then
        drillMS3:Destroy()
        drillMS3 = nil
    end
    if drillMS4 then
        drillMS4:Destroy()
        drillMS4 = nil
    end
end

-- Toggle button functionality
Tab3Section:NewToggle("Auto Attack", "Auto Do Drillmaster Attack", function(state)
    if state then
        createParts()
        
        -- Run the remote when toggled on
        local args = {
    [1] = "Royal City"
}

game:GetService("ReplicatedStorage").Remotes.Chuansong:FireServer(unpack(args))

    else
        deleteParts()
    end
end)








Tab4Section:NewButton("Infinite Yield","Op FE Admin Commands",function()

loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
end)

Tab4Section:NewButton("Nameless Admin","[NEW] OP Admin Commands",function()

-- Thanks to 0866 for making the whole ui work, this admin script was actually made in 2019 lol but was modified by qipu
-- For the commands thanks to IY, Fates Admin, HomeBrew, CMD-X for some of the code and command ideas!
-- For the people thanks to Digitality, i_db, rouxhaver, spec and the v3rmillion community, if you see your script in the source and want credits please dm qipu#9312
-- ! Make sure to have an executor that supports firetouchinterest for the tool commands !
loadstring(game:HttpGet("https://raw.githubusercontent.com/FilteringEnabled/NamelessAdmin/main/Source"))();
end)

Tab4Section:NewButton("Mobile Tab Glitch","You can tab glitch on mobile",function()

loadstring(game:HttpGet('https://raw.githubusercontent.com/creepstu/fuzzy-octo-giggle/main/Source'))()
end)

Tab4Section:NewButton("Instant Heal Health Button","Instant Heal",function()

----Instant Heal Health in Sword Warrior-----









local gui = Instance.new("ScreenGui")
gui.Name = "healGui"
gui.Parent = game.CoreGui

-- Create the TextButton
local TextButton = Instance.new("TextButton")
-- Text
TextButton.Text = "Heal\nHealth"
TextButton.TextSize = 14
-- Color
TextButton.TextColor3 = Color3.new(1, 1, 1)
TextButton.BackgroundColor3 = Color3.new(0, 0, 0)
TextButton.BorderColor3 = Color3.new(0, 0, 0)
-- Transparency
TextButton.BackgroundTransparency = 0.5
-- Thickness
TextButton.BorderSizePixel = 4
-- Text Code
TextButton.Font = Enum.Font.Code
-- Size (making it a small square)
TextButton.Size = UDim2.new(0, 50, 0, 50)  -- 50×50 pixels
-- Position
TextButton.Position = UDim2.new(1, -110, 0, 10)  -- Center of the screen
-- Function
TextButton.MouseButton1Click:Connect(function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/Tinalt/Scripts/main/HealSW", true))()
end)
TextButton.Parent = gui
TextButton.Draggable = true

-- Adding UICorner for rounded corners
local cornerUI = Instance.new("UICorner")
cornerUI.CornerRadius = UDim.new(0, 5)
cornerUI.Parent = TextButton

-- Adding UIStroke for border
local uiStroke = Instance.new("UIStroke")
uiStroke.Color = Color3.new(0, 0, 0)
uiStroke.Thickness = 2
uiStroke.Parent = TextButton


end)



Tab4Section:NewButton("Instant Heal + Attack Button","Instant Heal",function()

----Instant Heal + Attack in Sword Warrior-----









local gui = Instance.new("ScreenGui")
gui.Name = "atkGui"
gui.Parent = game.CoreGui

-- Create the TextButton
local TextButton = Instance.new("TextButton")
-- Text
TextButton.Text = "Heal\n+\nATK"
TextButton.TextSize = 14
-- Color
TextButton.TextColor3 = Color3.new(1, 1, 1)
TextButton.BackgroundColor3 = Color3.new(0, 0, 0)
TextButton.BorderColor3 = Color3.new(0, 0, 0)
-- Transparency
TextButton.BackgroundTransparency = 0.5
-- Thickness
TextButton.BorderSizePixel = 4
-- Text Code
TextButton.Font = Enum.Font.Code
-- Size (making it a small square)
TextButton.Size = UDim2.new(0, 50, 0, 50)  -- 50×50 pixels
-- Position
TextButton.Position = UDim2.new(1, -110, 0, 10)  -- Center of the screen
-- Function
TextButton.MouseButton1Click:Connect(function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/Tinalt/Scripts/main/Insteal%20Heal%20%2B%20Attack", true))()
end)
TextButton.Parent = gui
TextButton.Draggable = true

-- Adding UICorner for rounded corners
local cornerUI = Instance.new("UICorner")
cornerUI.CornerRadius = UDim.new(0, 5)
cornerUI.Parent = TextButton

-- Adding UIStroke for border
local uiStroke = Instance.new("UIStroke")
uiStroke.Color = Color3.new(0, 0, 0)
uiStroke.Thickness = 2
uiStroke.Parent = TextButton

end)



Tab4Section:NewButton("Tora IsMe Gui (Key)","Gui",function()

loadstring(game:HttpGet("https://raw.githubusercontent.com/ToraScript/Script/main/SwordWar", true))()
end)

Tab6Section:NewButton("Create Toggle Button", "Create Toggle UI Button", function()
    local gui = Instance.new("ScreenGui")
gui.Name = "tinGui"
gui.Parent = game.CoreGui

local TextButton = Instance.new("TextButton")
TextButton.Text = "Show\nui"
TextButton.TextSize = 14
TextButton.TextColor3 = Color3.new(1, 1, 1)
TextButton.BackgroundColor3 = Color3.new(0, 0, 0)
TextButton.BorderColor3 = Color3.new(0, 0, 0)
TextButton.BackgroundTransparency = 0.5
TextButton.BorderSizePixel = 4
TextButton.Font = Enum.Font.Code
TextButton.Size = UDim2.new(0, 50, 0, 50)
TextButton.Position = UDim2.new(1, -110, 0, 10)

local isVisible = false
TextButton.MouseButton1Click:Connect(function()
    isVisible = not isVisible
    if isVisible then
        TextButton.Text = "Hide\nui"
    else
        TextButton.Text = "Show\nui"
    end
    kavoUi:ToggleUI()
end)
TextButton.Parent = gui
TextButton.Draggable = true

local cornerUI = Instance.new("UICorner")
cornerUI.CornerRadius = UDim.new(0, 5)
cornerUI.Parent = TextButton

local uiStroke = Instance.new("UIStroke")
uiStroke.Color = Color3.new(0, 0, 0)
uiStroke.Thickness = 2
uiStroke.Parent = TextButton
end)

Tab6Section:NewButton("Destroy Toggle Button","Destroy ToggleUi button",function()

-- Function to delete all instances of "patrickGui" from CoreGui
local function deleteAllPatrickGui()
    local coreGui = game.CoreGui
    
    -- Iterate through each child in CoreGui
    for _, child in ipairs(coreGui:GetChildren()) do
        -- Check if the child is named "patrickGui"
        if child.Name == "tinGui" then
            -- Delete the patrickGui instance
            child:Destroy()
            print("Deleted patrickGui:", child.Name)
        end
    end
    
    print("All instances of patrickGui deleted.")
end

-- Call the function to delete all instances of "patrickGui"
deleteAllPatrickGui()
end)




-- Tab5 Section for teleportation buttons
Tab5Section:NewButton("Royal City", "Teleport to Royal City", function()
    local args = {
        [1] = "Royal City"
    }
    game:GetService("ReplicatedStorage").Remotes.Chuansong:FireServer(unpack(args))
end)

Tab5Section:NewButton("Outpost", "Teleport to Outpost", function()
    local args = {
        [1] = "Outpost"
    }
    game:GetService("ReplicatedStorage").Remotes.Chuansong:FireServer(unpack(args))
end)

Tab5Section:NewButton("Horde Camp", "Teleport to Horde Camp", function()
    local args = {
        [1] = "Horde Camp"
    }
    game:GetService("ReplicatedStorage").Remotes.Chuansong:FireServer(unpack(args))
end)

Tab5Section:NewButton("Glacial Chasm", "Teleport to Glacial Chasm", function()
    local args = {
        [1] = "Glacial Chasm"
    }
    game:GetService("ReplicatedStorage").Remotes.Chuansong:FireServer(unpack(args))
end)

Tab5Section:NewButton("Dark Castle", "Teleport to Dark Castle", function()
    local args = {
        [1] = "Dark Castle"
    }
    game:GetService("ReplicatedStorage").Remotes.Chuansong:FireServer(unpack(args))
end)

Tab5Section:NewButton("Taoyuan Township", "Teleport to Taoyuan Township", function()
    local args = {
        [1] = "Taoyuan Township"
    }
    game:GetService("ReplicatedStorage").Remotes.Chuansong:FireServer(unpack(args))
end)

Tab5Section:NewButton("Cemetery", "Teleport to Cemetery", function()
    local args = {
        [1] = "Cemetery"
    }
    game:GetService("ReplicatedStorage").Remotes.Chuansong:FireServer(unpack(args))
end)

Tab5Section:NewButton("Hell", "Teleport to Hell", function()
    local args = {
        [1] = "Hell"
    }
    game:GetService("ReplicatedStorage").Remotes.Chuansong:FireServer(unpack(args))
end)

Tab5Section:NewButton("Heaven", "Teleport to Heaven", function()
    local args = {
        [1] = "Heaven"
    }
    game:GetService("ReplicatedStorage").Remotes.Chuansong:FireServer(unpack(args))
end)

Tab5Section:NewButton("Solm Sand City", "Teleport to Solm Sand City", function()
    local args = {
        [1] = "Solm Sand City"
    }
    game:GetService("ReplicatedStorage").Remotes.Chuansong:FireServer(unpack(args))
end)

Tab5Section:NewButton("Wild", "Teleport to Wild", function()
    local args = {
        [1] = "Wild"
    }
    game:GetService("ReplicatedStorage").Remotes.Chuansong:FireServer(unpack(args))
end)

Tab5Section:NewButton("Titan Research Institute", "Teleport to Titan Research Institute", function()
    local args = {
        [1] = "Titan Research Institute"
    }
    game:GetService("ReplicatedStorage").Remotes.Chuansong:FireServer(unpack(args))
end)













-- Variables to hold references to the parts
local friend1, friend2, friend3, friend4
local canUseFriend2 = true -- Cooldown flag for Friend2
local canUseFriend4 = true -- Cooldown flag for Friend4

-- Function to create parts
local function createParts()
    -- Create the first part (Friend1)
    friend1 = Instance.new("Part", workspace)
    friend1.Position = Vector3.new(-38934.21, 13.66, 19524.97)
    friend1.Name = "Friend1"
    friend1.Size = Vector3.new(20, 3, 20)
    friend1.Anchored = true
    friend1.Transparency = 0.7

    -- Teleport functionality when touching Friend1
    friend1.Touched:Connect(function(hit)
        local player = game.Players:GetPlayerFromCharacter(hit.Parent)
        if player then
            local character = player.Character
            if character then
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    humanoidRootPart.CFrame = CFrame.new(-38926.78125, 4.9557647705078125, 19619.08984375)
                end
            end
        end
    end)

    -- Create the second part (Friend2)
    friend2 = Instance.new("Part", workspace)
    friend2.Position = Vector3.new(-38927, 1, 19683.29)
    friend2.Name = "Friend2"
    friend2.Size = Vector3.new(20, 1, 20)
    friend2.Anchored = true
    friend2.Transparency = 0.7

    -- Walking functionality and remote calls when touching Friend2
    friend2.Touched:Connect(function(hit)
        local player = game.Players:GetPlayerFromCharacter(hit.Parent)
        if player then
            local character = player.Character
            if character then
                local humanoid = character:FindFirstChild("Humanoid")
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if humanoid and humanoidRootPart then
                    humanoid:MoveTo(Vector3.new(-38926.88671875, 4.000006198883057, 19714.21875))

                    -- Wait until the character reaches the first position
                    humanoid.MoveToFinished:Wait()

                    if canUseFriend2 then
                        canUseFriend2 = false -- Start cooldown

                        local args1 = {
                            [1] = "ResetPoints"
                        }
                        game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args1))

                        wait(0.01) -- Wait before the next remote call

                        local args2 = {
                            [1] = "ClickPoints",
                            [2] = {
                                ["Points"] = 9999999999,
                                ["Obj"] = "GHealth"
                            }
                        }
                        game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args2))

                        wait(0.3) -- Wait for 0.35 seconds

                        -- Move to the second position
                        humanoid:MoveTo(Vector3.new(-38927.5859375, 4.499999523162842, 19768.15234375))

                        -- Wait until the character reaches the second position
                        humanoid.MoveToFinished:Wait()

                        wait(3) -- Cooldown period for Friend2
                        canUseFriend2 = true -- Reset cooldown
                    end
                end
            end
        end
    end)

    -- Create the third part (Friend3)
    friend3 = Instance.new("Part", workspace)
    friend3.Position = Vector3.new(-38928.21, 1, 19780.66)
    friend3.Name = "Friend3"
    friend3.Size = Vector3.new(30, 1, 30)
    friend3.Anchored = true
    friend3.Transparency = 0.7

    -- Teleport functionality when touching Friend3
    friend3.Touched:Connect(function(hit)
        local player = game.Players:GetPlayerFromCharacter(hit.Parent)
        if player then
            local character = player.Character
            if character then
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    humanoidRootPart.CFrame = CFrame.new(-38870, 4.3000054359436035, 19732)
                end
            end
        end
    end)

    -- Create the fourth part (Friend4)
    friend4 = Instance.new("Part", workspace)
    friend4.Position = Vector3.new(-38869.48, 1, 19731.26)
    friend4.Name = "Friend4"
    friend4.Size = Vector3.new(20, 1, 20)
    friend4.Anchored = true
    friend4.CanCollide = false
    friend4.Transparency = 0.7

    -- Remote calls when touching Friend4
    friend4.Touched:Connect(function(hit)
        local player = game.Players:GetPlayerFromCharacter(hit.Parent)
        if player and canUseFriend4 then
            canUseFriend4 = false -- Start cooldown
            
            local args1 = {
                [1] = "ResetPoints"
            }
            game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args1))

            wait(0.001)

            local args2 = {
                [1] = "ClickPoints",
                [2] = {
                    ["Points"] = 99999999,
                    ["Obj"] = "GHealth"
                }
            }
            game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args2))

            wait(0.001)

            local args3 = {
                [1] = "ResetPoints"
            }
            game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args3))

            wait(0.001)

local args = {
    [1] = "ClickPoints",
    [2] = {
        ["Points"] = 230,
        ["Obj"] = "GCriticalHit"
    }
}

game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args))

wait(0.001)

            local args4 = {
                [1] = "ClickPoints",
                [2] = {
                    ["Points"] = 99999999,
                    ["Obj"] = "GDamage"
                }
            }
            game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args4))
            
            wait(2) -- Cooldown period for Friend4
            canUseFriend4 = true -- Reset cooldown
        end
    end)
end

-- Function to delete parts
local function deleteParts()
    if friend1 then
        friend1:Destroy()
        friend1 = nil
    end
    if friend2 then
        friend2:Destroy()
        friend2 = nil
    end
    if friend3 then
        friend3:Destroy()
        friend3 = nil
    end
    if friend4 then
        friend4:Destroy()
        friend4 = nil
    end
end

-- Toggle button functionality
Tab1Section:NewToggle("Create Friends", "Create and Delete Friend Parts", function(state)
    if state then
        createParts()
    else
        deleteParts()
    end
end)























-- Variables to hold references to the parts
local friend1, friend2, friend3, friend4, friend5

-- Cooldown variables
local canSendRemote2 = true
local canSendRemote5 = true

-- Function to create parts
local function createParts()
    -- Create the first part (Friend1)
    friend1 = Instance.new("Part", workspace)
    friend1.Position = Vector3.new(-38934.21, 13.66, 19524.97)
    friend1.Name = "Friend1"
    friend1.Size = Vector3.new(20, 2, 20)
    friend1.Anchored = true
    friend1.CanCollide = false
    friend1.Transparency = 0.7

    -- Teleport functionality when touching Friend1
    friend1.Touched:Connect(function(hit)
        local player = game.Players:GetPlayerFromCharacter(hit.Parent)
        if player then
            local character = player.Character
            if character then
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    humanoidRootPart.CFrame = CFrame.new(-38927.37109375, 4.95576286315918, 19617.8515625)
                end
            end
        end
    end)

    -- Create the second part (Friend2)
    friend2 = Instance.new("Part", workspace)
    friend2.Position = Vector3.new(-38927, 1, 19683.29)
    friend2.Name = "Friend2"
    friend2.Size = Vector3.new(20, 1, 20)
    friend2.Anchored = true
    friend2.CanCollide = false
    friend2.Transparency = 0.7

    -- Walk to position functionality with remote call and cooldown when touching Friend2
friend2.Touched:Connect(function(hit)
    local player = game.Players:GetPlayerFromCharacter(hit.Parent)
    if player then
        local character = player.Character
        if character then
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid then
                if canSendRemote2 then
                    canSendRemote2 = false -- Set cooldown

                    -- First remote call
                    local args1 = {
                        [1] = "ResetPoints"
                    }
                    game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args1))

                    wait(0.001) -- Short wait

                    -- Second remote call
                    local args2 = {
                        [1] = "ClickPoints",
                        [2] = {
                            ["Points"] = 9999999,
                            ["Obj"] = "GHealth"
                        }
                    }
                    game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args2))

                    -- Walk to position after remote calls
                    humanoid:MoveTo(Vector3.new(-38926.6953125, 4.000005722045898, 19712.705078125))

                    wait(3) -- Cooldown duration
                    canSendRemote2 = true -- Reset cooldown
                end
            end
        end
    end
end)


    -- Create the third part (Friend3)
    friend3 = Instance.new("Part", workspace)
    friend3.Position = Vector3.new(-38925.8, 1, 19713.4)
    friend3.Name = "Friend3"
    friend3.Size = Vector3.new(17, 1, 10)
    friend3.Anchored = true
    friend3.CanCollide = false
    friend3.Transparency = 0.7

    -- Delayed walking functionality when touching Friend3
    friend3.Touched:Connect(function(hit)
        local player = game.Players:GetPlayerFromCharacter(hit.Parent)
        if player then
            local character = player.Character
            if character then
                local humanoid = character:FindFirstChild("Humanoid")
                if humanoid then
                    wait(0.3)
                    humanoid:MoveTo(Vector3.new(-38927.55859375, 4.00000524520874, 19766.70703125))
                end
            end
        end
    end)

    -- Create the fourth part (Friend4)
    friend4 = Instance.new("Part", workspace)
    friend4.Position = Vector3.new(-38928.21, 1, 19780.66)
    friend4.Name = "Friend4"
    friend4.Size = Vector3.new(30, 1, 30)
    friend4.Anchored = true
    friend4.CanCollide = false
    friend4.Transparency = 0.7

    -- Teleport functionality when touching Friend4
    friend4.Touched:Connect(function(hit)
        local player = game.Players:GetPlayerFromCharacter(hit.Parent)
        if player then
            local character = player.Character
            if character then
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    humanoidRootPart.CFrame = CFrame.new(-38870, 4.000006198883057, 19732)
                end
            end
        end
    end)

    -- Create the fifth part (Friend5)
    friend5 = Instance.new("Part", workspace)
    friend5.Position = Vector3.new(-38869.48, 1, 19731.26)
    friend5.Name = "Friend5"
    friend5.Size = Vector3.new(20, 1, 20)
    friend5.Anchored = true
    friend5.CanCollide = false
    friend5.Transparency = 0.7

    -- Run remote calls with cooldown when touching Friend5
    friend5.Touched:Connect(function(hit)
        local player = game.Players:GetPlayerFromCharacter(hit.Parent)
        if player and canSendRemote5 then
            canSendRemote5 = false -- Set cooldown

            local args1 = { [1] = "ResetPoints" }
            game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args1))
            wait(0.001)

            local args2 = {
                [1] = "ClickPoints",
                [2] = { ["Points"] = 99999999, ["Obj"] = "GHealth" }
            }
            game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args2))
            wait(0.001)

            local args3 = { [1] = "ResetPoints" }
            game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args3))
            wait(0.001)

            local args4 = {
                [1] = "ClickPoints",
                [2] = { ["Points"] = 230, ["Obj"] = "GCriticalHit" }
            }
            game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args4))
            wait(0.001)

            local args5 = {
                [1] = "ClickPoints",
                [2] = { ["Points"] = 9999999, ["Obj"] = "GDamage" }
            }
            game:GetService("ReplicatedStorage").CurRemotes.DataChange_Points:FireServer(unpack(args5))

            wait(2) -- Cooldown duration
            canSendRemote5 = true -- Reset cooldown
        end
    end)
end

-- Function to delete parts
local function deleteParts()
    if friend1 then
        friend1:Destroy()
        friend1 = nil
    end
    if friend2 then
        friend2:Destroy()
        friend2 = nil
    end
    if friend3 then
        friend3:Destroy()
        friend3 = nil
    end
    if friend4 then
        friend4:Destroy()
        friend4 = nil
    end
    if friend5 then
        friend5:Destroy()
        friend5 = nil
    end
end

-- Toggle button functionality
Tab1Section:NewToggle("Manage Friends", "Create/Delete Friends Parts", function(state)
    if state then
        createParts()
    else
        deleteParts()
    end
end)

